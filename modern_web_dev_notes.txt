------
Part 0 
------
Fundamentals of Web Apps 
server and web browser communicate with HTTP protocols
	- Code 200 == successful 

Traditional web applications 
	- Response headers:
		- size of the response in bytes 
		- exact time of response 
		- Content type tells us response is either text file, image/png etc. 

	- Response tab:
		- shows regular HTML page 
		- body section determines the structure of the rendered page 

	- browser does HTTP GET request to the server to fetch the HTML code of the page 
	- the img tag in the HTML prompts the browser to fetch the image. The browser renders the HTML page and the image to the screen
	- Writing HTML in the midst of the code is of course not smart, but for old-school PHP-programmers it was a normal practice.

DOM 
	- based on the idea of depicting HTML elements as a tree
	- DOM is an API, which enables programmatic modification of the element trees corresponding to web=-pages 

	- Manipulating DOM 
		- we can actually add to the DOM 
		- changes to modified DOM are not permanent. If the page is reloaded, the new note will disappear
			- changes not pushed to the server 

CSS (cascading style sheets)
	- markup language used to determine the appearance of web applications 
	- head of HTML element will contain a <link> tag to tell the browser to fetch the CSS style sheet
	- change on console will not be permanent
		- to make lasting changes, you would have to push to server 

Forms and HTTP Post 
	- request to server address new_note. 
	- server responds, but will force browser to get all resources again (fetch unnecessarily/wasting resources)
	- data is sent as the body of the POST-request 
	- server can access the data by accessing the req.body (req == request) 

AJAX (asynchronous JavaScript and XML)
	- enabled fetching of contents of webpages using JavaScript included within the HTML, without the need to re-render the page 
	- Prior to AJAX, all web pages worked like the traditional web app in previous section 
		- all of the data shown on the page was fetched with the HTML-code generated by the server 
		- not acceptable as they don't use the RESTful APIs
	- immediate, "in-place" update of page content 

Single page app 
	- Traditional web-page: 
		- all of the logic is on the server, and the browser only renders the HTML as instructed 
		- browser would reload the page - potentially causing more HTTP requests: fetching the style sheet, the JavaScript code, and the raw data of the notes 
			- data would be sent as the body of the POST-request 

	- SPA:
		- doesn't fetch all of their pages separately from the server like our application, but instead comprises of only one HTML page fetched from the server, the contents of which are manipulated with JavaScript that executes in the browser 
		- browser would only send one request to the server 
		- form tag is different: form has no action or method attributes to define how and where to send the input data 
		- page doesn't reload at any point of the process, nor does control transfer to another page 
			- obtains a JSON data file from the server (content-type: application/json - needed for browser to know how to parse data)
		- requires active JavaScript, because we need to manipulate DOM tree

JavaScript libraries 
	- different libraries containing tools tht are easier to work with compared to the DOM-API are of ten used to manipulate pages 
	- JQuery was developed backed when web-pages mainly followed the traditional style of the server generating HTML pages, the functionality of which was enhanced on the browser side using JavaScript written with JQuery

Full stack 
	- means focus is on FrontEnd, BackEnd, and Database 
	- user (Browser) related = front | server related = back 

------
Part 1
------
a. Introduction to React 
	- start learning how to use react 
		- component 
			- all content that needs to be rendered is usually defined as React components 

		- JSX 
			- Looks like React components are returning HTML markup, but actually under the hood JSX returned by React components is compiled into JavaScript 
			- same thing as HTML, except you can easily embed dynamic content by writing appropriate JavaScript within curly braces 
			
		- multiple components
			- Writing components with React is easy, and by combining components, even a more complex application can be kept fairly maintainable
			- core philosophy of React is composing applications from many specialized reusable components 

		- props: passing data to components 
			- we can pass data into components 
		
		- Other info:
			- console.log is useful for debugging purposes 
			- React components have to capitalized 
				- if we don't capitalize, React is only going to an empty element in the HTML 
			- Need at least one root element 

		Q: aren't components just functions / methods that return information to be rendered?

b. Javascript
	- section simply about JavaScripts syntax 
	- Variables 
		- in JS, variable scopes are only in functions 
		- JS gets "hoisted" to the top of function: as if they are defined at the beginning of the function
			- can keep "walking" up into the scopes; and accidentally declare global variables 
		- var: scope to immediate function body 
		- let: scope to immediate enclosing block {}

	- JS lambdas e.g.? 
		const t = [1, 2, 3]
		const m1 = t.map(value => value * 2)

	- Arrays: 
		- append is push 
		- accessing element at index is by using [] 

	- Objects:
		- can be accessed directly: no privileges 		

	- Functions:
		1) 
			const sum = (p1, p2) => {
			console.log(p1)
			console.log(p2)
			return p1 + p2
			}
			const result = sum(1, 5)
		
		2) 
			const square = p => {
			console.log(p)
			return p * p
			}
			const square = p => p * p

		3) 
			function product(a, b) {
			return a * b
			}
			const result = product(2, 6)


	- Classes:
		- we can simulate OOP, but JS doesn't have OOP functionalities 

c. Component state, event handlers 
	- Component helper functions
		- can write helper functions within components to make code cleaner 
		- unlike Java, we can define functions with other functions

	- Destructuring
		- streamline component by just declaring new variables and assigning them with values from prop
		- functions in JavaScript don't have to have an explicit return
			- by using arrow definition we can bypass this 
		
		- E.g.:
			const { name, age } = props
			const bornYear = () => new Date().getFullYear() - age

			// will automatically assign the props into {name, age} vars
			const Hello = ({ name, age }) => {

	- Page re-rendering
		- we can call ReactDom.render() multiple times to re-render page

	- Stateful component
		- allows state to be able to change during the lifecycle of the component 
		- uses "state hook" to hook into react features
			- when: write a function component that needs some state - we can Hook inside the existing function component

		Q: how is this different from just using a global variable to track counts?
		A(?): state is for re-rendering purposes, if we use global variables, it won't keep track of previous variable states?

	- Event handling
		- how should we handle a user's interaction with different elements of a web page 
		- clicking can log elements onto screen
		- E.g.: 
			<button onClick={() => console.log('clicked')}>

	- Event handler is a function
		- An event handler is supposed to be either a function or a function reference; it cannot be a function call 
		- defining event handlers within JSX-templates is not a good idea; should separate them into different functions

	- Passing state to child components
		- better to write React components that are small and reusable across the application and even across projects 
		- we can implement new functionality into our button clicking logic easily 

	- Refactoring the components
		- can refactor components to make code significant cleaner and more condense

d. A more complex state, debugging React apps
	- Complex state
	- Handling arrays
	- Conditional rendering
	- Old React
	- Debugging React applications
	- Rules of Hooks
	- Event Handling Revisited
	- Function that returns a function
	- Passing Event Handlers to Child Components
	- Do Not Define Components Within Components
